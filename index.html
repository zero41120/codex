<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>OW Stadium Build Planner - Max Stat Calculator</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    :root {
      --primary: #2196f3;
      --primary-light: #f0f8ff;
      --bg: linear-gradient(135deg, #f4f8fb 0%, #e4ecf7 100%);
      --card-bg: #fff;
      --border: #e8eaf0;
      --text: #273151;
      --text-secondary: #34495e;
      --item-teal: #20baa2;
      --item-science: #2196f3;
      --item-epic: #a020cf;
    }
    
    body {
      font-family: 'Segoe UI', Arial, sans-serif;
      background: var(--bg);
      margin: 0;
      padding: 0;
      min-height: 100vh;
      color: var(--text);
    }
    
    .container {
      max-width: 900px;
      background: var(--card-bg);
      box-shadow: 0 8px 32px #0001;
      border-radius: 16px;
      margin: 2em auto;
      padding: 0;
      border: 1.5px solid var(--border);
      display: flex;
      flex-direction: row;
      min-height: 550px;
      overflow: hidden;
    }
    
    .left-panel, .right-panel {
      padding: 1.6em 1.2em 1.2em 1.5em;
    }
    
    .left-panel {
      width: 340px;
      min-width: 260px;
      background: #fafdff;
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      gap: 0.25em;
    }
    
    .right-panel {
      flex: 1;
      background: var(--card-bg);
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      padding-left: 2em;
      padding-top: 2.3em;
    }
    
    h1 {
      font-size: 1.18em;
      margin: 0 0 1.2em 0;
      font-weight: 700;
      color: var(--primary);
      letter-spacing: 0.01em;
      text-align: left;
      text-shadow: 0 2px 8px #9fd5ff30;
    }
    
    label {
      display: block;
      margin-top: 0.7em;
      font-weight: 500;
      color: var(--text-secondary);
      letter-spacing: 0.01em;
      font-size: 1em;
    }
    
    select, input[type="number"] {
      margin-top: .4em;
      padding: 0.38em 0.6em;
      border-radius: 7px;
      border: 1px solid #b8d1e1;
      background: #fafdff;
      color: #213152;
      font-size: 1em;
      width: 100%;
      box-sizing: border-box;
      margin-bottom: 0.2em;
      transition: border .2s;
    }
    
    select:focus, input[type="number"]:focus {
      border: 1.5px solid var(--primary);
      outline: none;
      background: var(--primary-light);
    }
    
    #stat:disabled { color: #bbb; background: #f5f6fa; }
    #baseHealth, #baseShield, #baseArmor, #maxItems, #cash { width: 100%; }
    
    .reserve-fields {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      margin-top: 0.8em;
      gap: 0.4em 0.7em;
      background: #f4f8fb;
      border-radius: 7px;
      padding: 0.5em .7em .3em .7em;
    }
    
    .reserve-fields label {
      margin: 0;
      color: #357ba1;
      font-weight: 400;
      font-size: 0.97em;
      display: flex;
      align-items: center;
      gap: 0.3em;
    }
    
    .reserve-fields input[type="number"] {
      width: 75px;
      min-width: 30px;
      padding: 0.32em 0.3em;
      margin: 0;
      font-size: 0.99em;
    }
    
    .reserve-fields b {
      flex-basis: 100%;
      margin-bottom: .2em;
      color: #2777c6;
      font-weight: 600;
      font-size: 1.07em;
      letter-spacing: 0.01em;
    }
    
    button {
      margin-top: 1.1em;
      padding: 0.55em 1.4em;
      border-radius: 9px;
      border: none;
      background: linear-gradient(90deg, #52b9ff 10%, #8be4cf 90%);
      color: #13304a;
      font-weight: 700;
      font-size: 1.09em;
      box-shadow: 0 2px 10px #59c6ef11;
      cursor: pointer;
      transition: background .22s, color .22s;
      letter-spacing: 0.02em;
      width: 100%;
    }
    
    button:hover {
      background: linear-gradient(90deg, #2196f3 0%, #6df3e7 100%);
      color: #fff;
    }
    
    #result {
      font-weight: bold;
      border-radius: 7px;
      background: #f7fafd;
      padding: 1.1em 1em 1em 1em;
      min-height: 2.2em;
      box-shadow: 0 2px 10px #b2dbff2a;
      color: #233151;
      font-size: 1.04em;
      margin-bottom: 1em;
      word-break: break-word;
    }
    
    #loading { color: var(--primary); font-weight: 400; }
    .item-list, .alt-list { margin-top: .5em; font-size: 1em; }
    .item-list ul, .alt-list ul { margin: .2em 0 .2em 1.3em; }
    .alt-list { margin-top: 1em; color: #5aa3bb; }
    .item-teal { color: var(--item-teal); font-weight: 600; }
    .item-science { color: var(--item-science); font-weight: 600; }
    .item-epic { color: var(--item-epic); font-weight: 600; }
    .item-list li, .alt-list li { margin-bottom: 2px; }
    #baseStats-label label { margin-top: 0.4em; }
    
    @media (max-width: 900px) {
      .container { flex-direction: column; max-width: 97vw; }
      .right-panel { padding-left: 1em; padding-top: 1.2em; }
      .left-panel { width: 100%; min-width: unset; }
    }
    
    @media (max-width: 600px) {
      .left-panel, .right-panel { padding: 1em 0.3em; }
      h1 { font-size: 1em; }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="left-panel">
      <h1>OW Stadium Build Planner<br><span style="font-size:.86em;font-weight:400;display:block;margin-top:.1em;letter-spacing:.03em;">Max Stat Calculator</span></h1>
      <label>Cash Amount:<input id="cash" type="number" min="0" value="10000"></label>
      <div class="reserve-fields">
        <b>Reserve cash for 5 items (excluded from calculation):</b>
        <label>1: <input id="reserve1" type="number" min="0" value="0"></label>
        <label>2: <input id="reserve2" type="number" min="0" value="0"></label>
        <label>3: <input id="reserve3" type="number" min="0" value="0"></label>
        <label>4: <input id="reserve4" type="number" min="0" value="0"></label>
        <label>5: <input id="reserve5" type="number" min="0" value="0"></label>
      </div>
      <label>Number of Items:<input id="maxItems" type="number" min="1" max="6" value="5"></label>
      <label>Hero:<select id="hero"></select></label>
      <label>Stat:<select id="stat"></select></label>
      <div id="baseStats-label" style="display:none;">
        <label>Base Health: <input id="baseHealth" type="number" min="0" value="250"></label>
        <label>Base Shield: <input id="baseShield" type="number" min="0" value="250"></label>
        <label>Base Armor: <input id="baseArmor" type="number" min="0" value="250"></label>
      </div>
      <button id="calculate">Calculate Max Value</button>
      <div id="loading"></div>
    </div>
    <div class="right-panel">
      <div id="result"></div>
    </div>
  </div>
<script>
// Constants and state
const CONSTANTS = {
  HP_STATS: ["Health", "Shield", "Armor"],
  HIT_POINT_STAT: "Hit Point",
  WEAPON_EFFECT_STAT: "Weapon Effect",
  MAX_ITEMS: 6,
  STAT_DISPLAY_NAMES: {
    WP: "Weapon Power (WP)", AP: "Ability Power (AP)", AS: "Attack Speed (AS)",
    MA: "Max Ammo (MA)", CR: "Critical Rate (CR)", RS: "Reload Speed (RS)",
    MS: "Move Speed (MS)", MD: "Melee Damage (MD)", Armor: "Armor",
    Health: "Health", Shield: "Shield", "Hit Point": "Hit Point (Health+Shield+Armor)",
    "Weapon Effect": "Weapon Effect (WP+AS)", "Knockback Resist": "Knockback Resist",
    "WPLS": "Weapon Lifesteal (WPLS)", "CD": "Cooldown Reduction (CD)"
  }
};

// Application state
const state = {
  items: [],
  heroes: [],
  data: null
};

// Utility functions
const util = {
  parsePercent: v => typeof v === "string" && /^([0-9.]+)%$/.test(v) ? parseFloat(v) : 0,
  roundInt: x => Math.round(x),
  arraysEqual: (a, b) => a.length === b.length && 
    a.map(x => x.id || x.name).sort().every((id, i) => id === (b.map(x => x.id || x.name).sort()[i])),
  getPriceClass: c => c <= 1500 ? 'item-teal' : c >= 9000 ? 'item-epic' : 'item-science'
};

// Data functions
const dataFns = {
  getAllItems: d => {
    let result = [];
    for (let tabKey in d.tabs) {
      ["common", "rare", "epic"].forEach(quality => {
        d.tabs[tabKey][quality]?.forEach(item => result.push(item));
      });
    }
    return result;
  },
  
  getHeroList: items => {
    const set = new Set(["All"]);
    items.forEach(i => i.character && set.add(i.character));
    return [...set].sort();
  },
  
  getStatTypes: items => {
    const counts = {};
    const always = ["WP", "AP", "AS"];
    const { HP_STATS, HIT_POINT_STAT, WEAPON_EFFECT_STAT } = CONSTANTS;
    
    items.forEach(item => {
      item.attributes?.forEach(attr => {
        const type = attr.type;
        if (typeof type === "string" && type !== "description" && type !== "" && !type.startsWith("Max ") && !type.startsWith("[")) {
          counts[type] = (counts[type] || 0) + 1;
        }
      });
    });
    
    counts.WP = counts.WP || 0;
    
    let statList = Object.keys(counts).filter(stat => 
      always.includes(stat) ? counts[stat] > 0 : counts[stat] >= 3
    );
    
    const hpCount = HP_STATS.reduce((n, s) => n + (counts[s] || 0), 0);
    if (hpCount >= 3) statList.push(HIT_POINT_STAT);
    
    const wpCount = counts.WP || 0;
    const asCount = counts.AS || 0;
    if (wpCount + asCount >= 3) statList.push(WEAPON_EFFECT_STAT);
    
    return [
      ...always.filter(s => statList.includes(s)),
      ...statList.filter(s => !always.includes(s) && s !== HIT_POINT_STAT && s !== WEAPON_EFFECT_STAT).sort(),
      ...(statList.includes(HIT_POINT_STAT) ? [HIT_POINT_STAT] : []),
      ...(statList.includes(WEAPON_EFFECT_STAT) ? [WEAPON_EFFECT_STAT] : [])
    ];
  },
  
  getStatValue: (item, hero, stat) => {
    // Special case for Ashe with specific items
    if (hero === "Ashe" && stat === "WP") {
      if (item.name?.toUpperCase() === "TRIPOD") return 13;
      if (item.name?.toUpperCase() === "IRONSIGHTS") return 20;
    }
    
    let value = 0;
    item.attributes?.forEach(attr => {
      if (attr.type === stat) value += util.parsePercent(attr.value);
    });
    
    return value;
  },
  
  getHPStatValueCombo: (items, stat, base) => {
    let flat = 0, percent = 0;
    
    items.forEach(item => {
      item.attributes?.forEach(attr => {
        if (attr.type === stat) {
          if (typeof attr.value === "string" && attr.value.endsWith("%")) {
            percent += util.parsePercent(attr.value);
          } else {
            flat += (+attr.value || 0);
          }
        }
      });
    });
    
    const total = (base + flat) * (1 + percent / 100);
    const plus = total - base;
    
    return { total, plus, flat, percent };
  }
};

// Core calculation functions
const calcFns = {
  // Unified search function for all stat types
  search: (params) => {
    const { items, cash, hero, stat, baseH, baseS, baseA, maxItems } = params;
    const { HP_STATS, HIT_POINT_STAT, WEAPON_EFFECT_STAT } = CONSTANTS;
    
    // Filter relevant items
    const relevant = items.filter(it => 
      hero === "All" ? !it.character : !it.character || it.character === hero
    );
    
    // Handle special stat types
    if (stat === HIT_POINT_STAT) {
      return calcFns.calculateHitPointCombo(relevant, cash, baseH, baseS, baseA, maxItems);
    }
    
    if (stat === WEAPON_EFFECT_STAT) {
      return calcFns.calculateWeaponEffectCombo(relevant, cash, hero, maxItems);
    }
    
    if (HP_STATS.includes(stat)) {
      return calcFns.calculateHPStatCombo(relevant, cash, stat, 
        stat === "Health" ? baseH : stat === "Shield" ? baseS : baseA, maxItems);
    }
    
    // Standard stat search
    const statItems = relevant
      .map(it => {
        const v = dataFns.getStatValue(it, hero, stat);
        return v > 0 ? {...it, statValue: v} : null;
      })
      .filter(Boolean);
    
    let max = 0;
    let bestCombos = [];
    
    const searchRecursive = (i, curCash, curStat, picked) => {
      if (picked.length > maxItems) return;
      
      if (i >= statItems.length) {
        if (curStat > max) {
          max = curStat;
          bestCombos = [{items: [...picked], cost: curCash}];
        } else if (curStat === max && max > 0 && !bestCombos.some(c => util.arraysEqual(c.items, picked))) {
          bestCombos.push({items: [...picked], cost: curCash});
        }
        return;
      }
      
      // Skip this item
      searchRecursive(i + 1, curCash, curStat, picked);
      
      // Take this item if we can afford it
      const item = statItems[i];
      if (curCash + item.cost <= cash) {
        picked.push(item);
        searchRecursive(i + 1, curCash + item.cost, curStat + item.statValue, picked);
        picked.pop();
      }
    };
    
    searchRecursive(0, 0, 0, []);
    
    if (!bestCombos.length) {
      return { max: 0, picked: [], alternatives: [] };
    }
    
    const minCost = Math.min(...bestCombos.map(c => c.cost));
    const best = bestCombos.filter(c => c.cost === minCost);
    const alternatives = bestCombos.filter(c => c.cost > minCost);
    
    return {
      max,
      picked: best[0].items,
      bestCost: best[0].cost,
      alternatives
    };
  },
  
  calculateHitPointCombo: (relevant, cash, baseH, baseS, baseA, maxItems) => {
    const hpItems = relevant.filter(it => 
      it.attributes?.some(a => CONSTANTS.HP_STATS.includes(a.type))
    );
    
    let max = 0;
    let bestCombos = [];
    
    const searchRecursive = (i, curCash, picked) => {
      if (picked.length > maxItems) return;
      
      if (i >= hpItems.length) {
        const perType = {
          Health: dataFns.getHPStatValueCombo(picked, "Health", baseH),
          Shield: dataFns.getHPStatValueCombo(picked, "Shield", baseS),
          Armor: dataFns.getHPStatValueCombo(picked, "Armor", baseA)
        };
        
        const sum = perType.Health.total + perType.Shield.total + perType.Armor.total - (baseH + baseS + baseA);
        
        if (sum > max) {
          max = sum;
          bestCombos = [{
            items: [...picked],
            cost: curCash,
            perType,
            total: perType.Health.total + perType.Shield.total + perType.Armor.total
          }];
        } else if (sum === max && max > 0 && !bestCombos.some(c => util.arraysEqual(c.items, picked))) {
          bestCombos.push({
            items: [...picked],
            cost: curCash,
            perType,
            total: perType.Health.total + perType.Shield.total + perType.Armor.total
          });
        }
        return;
      }
      
      // Skip this item
      searchRecursive(i + 1, curCash, picked);
      
      // Take this item if we can afford it
      const item = hpItems[i];
      if (curCash + item.cost <= cash) {
        picked.push(item);
        searchRecursive(i + 1, curCash + item.cost, picked);
        picked.pop();
      }
    };
    
    searchRecursive(0, 0, []);
    
    if (!bestCombos.length) {
      return {
        max: 0,
        picked: [],
        alternatives: [],
        total: baseH + baseS + baseA,
        perType: {
          Health: { total: baseH },
          Shield: { total: baseS },
          Armor: { total: baseA }
        }
      };
    }
    
    const minCost = Math.min(...bestCombos.map(c => c.cost));
    const best = bestCombos.filter(c => c.cost === minCost);
    const alternatives = bestCombos.filter(c => c.cost > minCost);
    
    return {
      max,
      picked: best[0].items,
      bestCost: best[0].cost,
      alternatives,
      total: best[0].total,
      perType: best[0].perType
    };
  },
  
  calculateWeaponEffectCombo: (relevant, cash, hero, maxItems) => {
    const effectItems = relevant.filter(it => {
      let hasEffect = it.attributes?.some(a => ["WP", "AS"].includes(a.type));
      if (hero === "Ashe" && it.name && ["TRIPOD", "IRONSIGHTS"].includes(it.name.toUpperCase())) {
        hasEffect = true;
      }
      return hasEffect;
    });
    
    let max = 0;
    let bestCombos = [];
    
    const getEffectStats = (picked) => {
      let wp = 0, as = 0;
      
      picked.forEach(it => {
        if (hero === "Ashe") {
          if (it.name?.toUpperCase() === "TRIPOD") wp += 13;
          if (it.name?.toUpperCase() === "IRONSIGHTS") wp += 20;
        }
        
        it.attributes?.forEach(a => {
          if (a.type === "WP") wp += util.parsePercent(a.value);
          if (a.type === "AS") as += util.parsePercent(a.value);
        });
      });
      
      return { wp, as };
    };
    
    const searchRecursive = (i, curCash, picked) => {
      if (picked.length > maxItems) return;
      
      if (i >= effectItems.length) {
        const { wp, as } = getEffectStats(picked);
        const effect = (1 + wp / 100) * (1 + as / 100);
        
        if (effect > max) {
          max = effect;
          bestCombos = [{ items: [...picked], cost: curCash, wp, as, effect }];
        } else if (effect === max && max > 1 && !bestCombos.some(c => util.arraysEqual(c.items, picked))) {
          bestCombos.push({ items: [...picked], cost: curCash, wp, as, effect });
        }
        return;
      }
      
      // Skip this item
      searchRecursive(i + 1, curCash, picked);
      
      // Take this item if we can afford it
      const item = effectItems[i];
      if (curCash + item.cost <= cash) {
        picked.push(item);
        searchRecursive(i + 1, curCash + item.cost, picked);
        picked.pop();
      }
    };
    
    searchRecursive(0, 0, []);
    
    if (!bestCombos.length) {
      return { max: 1, picked: [], alternatives: [], wp: 0, as: 0 };
    }
    
    const minCost = Math.min(...bestCombos.map(c => c.cost));
    const best = bestCombos.filter(c => c.cost === minCost);
    const alternatives = bestCombos.filter(c => c.cost > minCost);
    
    return {
      max: best[0].effect,
      picked: best[0].items,
      bestCost: best[0].cost,
      alternatives,
      wp: best[0].wp,
      as: best[0].as
    };
  },
  
  calculateHPStatCombo: (relevant, cash, stat, base, maxItems) => {
    const statItems = relevant.filter(it => 
      it.attributes?.some(a => a.type === stat)
    );
    
    let max = 0;
    let bestCombos = [];
    
    const searchRecursive = (i, curCash, picked) => {
      if (picked.length > maxItems) return;
      
      if (i >= statItems.length) {
        const { total, plus } = dataFns.getHPStatValueCombo(picked, stat, base);
        
        if (plus > max) {
          max = plus;
          bestCombos = [{ items: [...picked], cost: curCash, total, plus }];
        } else if (plus === max && max > 0 && !bestCombos.some(c => util.arraysEqual(c.items, picked))) {
          bestCombos.push({ items: [...picked], cost: curCash, total, plus });
        }
        return;
      }
      
      // Skip this item
      searchRecursive(i + 1, curCash, picked);
      
      // Take this item if we can afford it
      const item = statItems[i];
      if (curCash + item.cost <= cash) {
        picked.push(item);
        searchRecursive(i + 1, curCash + item.cost, picked);
        picked.pop();
      }
    };
    
    searchRecursive(0, 0, []);
    
    if (!bestCombos.length) {
      return { max: 0, picked: [], alternatives: [], total: base };
    }
    
    const minCost = Math.min(...bestCombos.map(c => c.cost));
    const best = bestCombos.filter(c => c.cost === minCost);
    const alternatives = bestCombos.filter(c => c.cost > minCost);
    
    return {
      max,
      picked: best[0].items,
      bestCost: best[0].cost,
      alternatives,
      total: best[0].total
    };
  }
};

// UI functions
const ui = {
  populateStatOptions: (stats) => {
    const select = document.getElementById('stat');
    select.innerHTML = "";
    
    stats.forEach(stat => {
      const option = document.createElement('option');
      option.value = stat;
      option.textContent = CONSTANTS.STAT_DISPLAY_NAMES[stat] || stat;
      select.appendChild(option);
    });
    
    select.disabled = !stats.length;
    ui.showBaseHPIfNeeded();
  },
  
  populateHeroes: () => {
    const select = document.getElementById('hero');
    select.innerHTML = "";
    
    state.heroes.forEach(hero => {
      const option = document.createElement('option');
      option.value = hero;
      option.textContent = hero;
      select.appendChild(option);
    });
  },
  
  showBaseHPIfNeeded: () => {
    const stat = document.getElementById('stat').value;
    document.getElementById('baseStats-label').style.display = 
      CONSTANTS.HP_STATS.includes(stat) || stat === CONSTANTS.HIT_POINT_STAT ? "" : "none";
  },
  
  renderResults: (result, params) => {
    const { stat, baseH, baseS, baseA, totalReserve } = params;
    const { HIT_POINT_STAT, WEAPON_EFFECT_STAT, HP_STATS, STAT_DISPLAY_NAMES } = CONSTANTS;
    
    const statLabel = STAT_DISPLAY_NAMES[stat] || stat;
    let html = "";
    
    if (stat === HIT_POINT_STAT) {
      html = `
        <div>Max <b>${statLabel}</b> achievable: <span style="color: #2196f3">+${util.roundInt(result.max)}</span> 
          (Total: <b>${util.roundInt(result.total)}</b>, base: ${util.roundInt(baseH + baseS + baseA)}, 
          <span style="color:#4db6ac">${result.bestCost || 0} cash</span>)
        </div>
        <div>Breakdown: 
          <span style="color:#2196f3">Health</span> <b>${util.roundInt(result.perType.Health.total)}</b> + 
          <span style="color:#a020cf">Armor</span> <b>${util.roundInt(result.perType.Armor.total)}</b> + 
          <span style="color:#20baa2">Shield</span> <b>${util.roundInt(result.perType.Shield.total)}</b>
        </div>
      `;
    } else if (stat === WEAPON_EFFECT_STAT) {
      const percentIncrease = ((result.max - 1) * 100).toFixed(2);
      html = `
        <div>Max <b>${statLabel}</b> achievable: <span style="color:#20baa2">+${percentIncrease}%</span> 
          (WP: +${result.wp}%, AS: +${result.as}%, <span style="color:#4db6ac">${result.bestCost || 0} cash</span>)
        </div>
      `;
    } else if (HP_STATS.includes(stat)) {
      const baseValue = stat === "Health" ? baseH : stat === "Shield" ? baseS : baseA;
      html = `
        <div>Max <b>${statLabel}</b> achievable: <span style="color:#2196f3">+${util.roundInt(result.max)}</span> 
          (Total: <b>${util.roundInt(result.total)}</b>, base: ${util.roundInt(baseValue)}, 
          <span style="color:#4db6ac">${result.bestCost || 0} cash</span>)
        </div>
      `;
    } else {
      html = `
        <div>Max <b>${statLabel}</b> achievable: <span style="color:#20baa2">${result.max}%</span> 
          (<span style="color:#4db6ac">${result.bestCost || 0} cash</span>)
        </div>
      `;
    }
    
    if (result.picked.length) {
      html += `<div class="item-list"><b>Picked items:</b><ul>`;
      
      result.picked.forEach(item => {
        const priceClass = util.getPriceClass(item.cost);
        let statValue = "";
        
        if (stat === HIT_POINT_STAT) {
          const statParts = [];
          
          HP_STATS.forEach(hpStat => {
            let flat = 0, percent = 0;
            
            item.attributes?.forEach(attr => {
              if (attr.type === hpStat) {
                if (typeof attr.value === "string" && attr.value.endsWith("%")) {
                  percent += util.parsePercent(attr.value);
                } else {
                  flat += (+attr.value || 0);
                }
              }
            });
            
            if (flat) statParts.push(`${hpStat}: +${flat}`);
            if (percent) statParts.push(`${hpStat}: +${percent}%`);
          });
          
          statValue = statParts.join(" | ");
        } else if (stat === WEAPON_EFFECT_STAT) {
          let wp = 0, as = 0;
          
          if (params.hero === "Ashe") {
            if (item.name?.toUpperCase() === "TRIPOD") wp += 13;
            if (item.name?.toUpperCase() === "IRONSIGHTS") wp += 20;
          }
          
          item.attributes?.forEach(attr => {
            if (attr.type === "WP") wp += util.parsePercent(attr.value);
            if (attr.type === "AS") as += util.parsePercent(attr.value);
          });
          
          const parts = [];
          if (wp) parts.push(`WP: +${wp}%`);
          if (as) parts.push(`AS: +${as}%`);
          statValue = parts.join(" & ");
        } else if (HP_STATS.includes(stat)) {
          let flat = 0, percent = 0;
          
          item.attributes?.forEach(attr => {
            if (attr.type === stat) {
              if (typeof attr.value === "string" && attr.value.endsWith("%")) {
                percent += util.parsePercent(attr.value);
              } else {
                flat += (+attr.value || 0);
              }
            }
          });
          
          const parts = [];
          if (flat) parts.push(`+${flat}`);
          if (percent) parts.push(`+${percent}%`);
          statValue = parts.length ? parts.join(" & ") : "";
        } else {
          statValue = `+${item.statValue}%`;
        }
        
        html += `
          <li class="${priceClass}">
            ${item.name} 
            <span style="color:#555;font-size:.94em">
              (${item.cost} cash, ${statValue}${item.character ? ', ' + item.character : ''})
            </span>
          </li>
        `;
      });
      
      html += `</ul></div>`;
    } else {
      html += "<div style='color:#ea4f4f'>No items found for this combination.</div>";
    }
    
    if (result.alternatives?.length > 0) {
      html += `<div class="alt-list"><b>Alternative combinations (same value, different cost):</b><ul>`;
      
      result.alternatives.forEach(combo => {
        html += `<li>
          ${combo.items.map(item => {
            const priceClass = util.getPriceClass(item.cost);
            return `<span class="${priceClass}">${item.name}</span>`;
          }).join(' + ')} 
          (${combo.cost} cash)
        </li>`;
      });
      
      html += `</ul></div>`;
    }
    
    document.getElementById('result').innerHTML = html;
  }
};

// Main calculation function
function doCalculate() {
  if (!state.items.length) {
    document.getElementById('result').innerHTML = "<span style='color: #d32f2f'>Data not loaded yet.</span>";
    return;
  }
  
  const statSelect = document.getElementById('stat');
  if (statSelect.options.length === 0 || statSelect.disabled) {
    document.getElementById('result').innerHTML = "<span style='color: #d32f2f'>No valid stat types with at least 3 items.</span>";
    return;
  }
  
  // Get form values
  const cash = parseInt(document.getElementById('cash').value, 10);
  const reserves = [1, 2, 3, 4, 5].map(i => parseInt(document.getElementById('reserve' + i).value, 10) || 0);
  const totalReserve = reserves.reduce((a, b) => a + b, 0);
  const hero = document.getElementById('hero').value;
  const stat = statSelect.value;
  const baseH = CONSTANTS.HP_STATS.includes(stat) || stat === CONSTANTS.HIT_POINT_STAT 
    ? parseInt(document.getElementById('baseHealth').value, 10) : 0;
  const baseS = CONSTANTS.HP_STATS.includes(stat) || stat === CONSTANTS.HIT_POINT_STAT 
    ? parseInt(document.getElementById('baseShield').value, 10) : 0;
  const baseA = CONSTANTS.HP_STATS.includes(stat) || stat === CONSTANTS.HIT_POINT_STAT 
    ? parseInt(document.getElementById('baseArmor').value, 10) : 0;
  const maxItems = Math.min(Math.max(parseInt(document.getElementById('maxItems').value, 10) || 5, 1), CONSTANTS.MAX_ITEMS);
  
  // Calculate available cash after reserves
  const availableCash = Math.max(0, cash - totalReserve);
  
  // Perform calculation
  const result = calcFns.search({
    items: state.items, 
    cash: availableCash, 
    hero, 
    stat, 
    baseH, 
    baseS, 
    baseA, 
    maxItems
  });
  
  // Render results
  ui.renderResults(result, { stat, baseH, baseS, baseA, totalReserve });
}

// Data loading
async function loadData() {
  document.getElementById('loading').textContent = "Loading data...";
  
  try {
    const resp = await fetch('https://raw.githubusercontent.com/legovader09/OW-Stadium-Build-Planner/0443f4550d3640231832a4c16c9d8a185091d7d8/public/static/data/data-original.json');
    
    if (!resp.ok) {
      throw new Error("Failed to fetch data");
    }
    
    state.data = await resp.json();
    state.items = dataFns.getAllItems(state.data);
    state.heroes = dataFns.getHeroList(state.items);
    
    ui.populateStatOptions(dataFns.getStatTypes(state.items));
    ui.populateHeroes();
    
    document.getElementById('loading').textContent = "";
  } catch (error) {
    document.getElementById('loading').textContent = "Failed to load data.";
    console.error("Error loading data:", error);
  }
}

// Event listeners
document.getElementById('calculate').addEventListener('click', doCalculate);
document.getElementById('cash').addEventListener('keydown', e => {
  if (e.key === "Enter") doCalculate();
});
document.getElementById('stat').addEventListener('change', ui.showBaseHPIfNeeded);

// Initialize the app
loadData();
</script>
</body>
</html>
